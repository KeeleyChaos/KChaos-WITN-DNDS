<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Canvas with Physics</title>
  <style>
    .controls { position: absolute; top: 10px; left: 10px; z-index: 100; color: white; }
    body { margin: 0; overflow: hidden; background-color: #000000; }
    canvas { border: none; touch-action: none; background-color: transparent; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
  </style>
</head>
<body>
  <div class="controls">
    <select id="shape">
        <option value="rectangle">
          Rectangle
        </option>
        <option value="triangle">
          Triangle
        </option>
        <option value="oval">
          Oval
        </option>
      </select>
     <button onclick="createShape(document.getElementById('shape').value, parseFloat(document.getElementById('xCoord').value), parseFloat(document.getElementById('yCoord').value), parseFloat(document.getElementById('xScale').value), parseFloat(document.getElementById('yScale').value))">
  Create Object
</button>
      <button onclick="toggleEraseMode()">
  Erase
</button>
    <input type="file" id="backgroundInput" style="display: none;" onchange="changeBackground(this)" accept="image/*">
    <button onclick="document.getElementById('backgroundInput').click()">Select Background</button>
      <br>
      X Coordinate:
      <input type="text" id="xCoord" value="400">
      <br>
      Y Coordinate:
      <input type="text" id="yCoord" value="300">
      <br>
      X Scale:
      <input type="text" id="xScale" value="100">
      <br>
      Y Scale:
      <input type="text" id="yScale" value="100">
      <br>
  </div>
  <canvas id="canvas"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.16.0"></script>
  <script>

    // Matter.js module aliases
        var Engine = Matter.Engine,
        Render = Matter.Render,
        World = Matter.World,
        Bodies = Matter.Bodies,
        Mouse = Matter.Mouse,
        MouseConstraint = Matter.MouseConstraint;

        // Create an engine
        var engine = Engine.create();

        // Create a renderer
        var render = Render.create({
          element: document.body,
          engine: engine,
          canvas: document.getElementById('canvas'),
          options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false
          }
        });

        // Add walls
        var wallThickness = 20;
        var wallOptions = { 
  isStatic: true, 
  render: { visible: false },
  label: 'wall' // Unique label for walls
};
        World.add(engine.world, [Bodies.rectangle(window.innerWidth / 2, -wallThickness / 2, window.innerWidth, wallThickness, wallOptions), // top
        Bodies.rectangle(window.innerWidth / 2, window.innerHeight + wallThickness / 2, window.innerWidth, wallThickness, wallOptions), // bottom
        Bodies.rectangle( - wallThickness / 2, window.innerHeight / 2, wallThickness, window.innerHeight, wallOptions), // left
        Bodies.rectangle(window.innerWidth + wallThickness / 2, window.innerHeight / 2, wallThickness, window.innerHeight, wallOptions) // right
        ]);

        // Function to create shapes
        function createShape(shapeType, x, y, xScale, yScale) {
          var body;
          if (shapeType === 'rectangle') {
            body = Bodies.rectangle(x, y, xScale, yScale, {
              render: {
                fillStyle: 'white',
                strokeStyle: 'black',
                lineWidth: 2
              }
            });
          } else if (shapeType === 'triangle') {
            // Create a triangle body by using a polygon with 3 vertices
            body = Bodies.polygon(x, y, 3, xScale / 2, {
              render: {
                fillStyle: 'white',
                strokeStyle: 'black',
                lineWidth: 2
              }
            });
          } else if (shapeType === 'oval') {
            // Create an oval body by using a circle and scaling it
            body = Bodies.circle(x, y, xScale / 2, {
              render: {
                fillStyle: 'white',
                strokeStyle: 'black',
                lineWidth: 2
              }
            });
            Matter.Body.scale(body, 1, yScale / xScale);
          }
          World.add(engine.world, body);
        }

        // Add mouse control
        var mouse = Mouse.create(render.canvas),
        mouseConstraint = MouseConstraint.create(engine, {
          mouse: mouse,
          constraint: {
            stiffness: 0.2,
            render: {
              visible: false
            }
          }
        });

        World.add(engine.world, mouseConstraint);
        
// Initialize erase mode and mouse button state
var eraseMode = false;
var mouseButtonIsDown = false;

// Function to toggle erase mode
function toggleEraseMode() {
  eraseMode = !eraseMode;
  document.body.style.cursor = eraseMode ? 'crosshair' : 'default';
}

// Event listener for mouse button down
document.addEventListener('mousedown', function(event) {
  // Check if the left mouse button is pressed
  if (event.button === 0) {
    mouseButtonIsDown = true;
  }
});

// Event listener for mouse button up
document.addEventListener('mouseup', function(event) {
  // Check if the left mouse button is released
  if (event.button === 0) {
    mouseButtonIsDown = false;
  }
});

// Event listener for mouse move
document.addEventListener('mousemove', handleInteraction);

// Event listener for touch start
document.addEventListener('touchstart', function(event) {
  
  mouseButtonIsDown = true;
  handleInteraction(event.touches[0]);
}, { passive: false });

// Event listener for touch end
document.addEventListener('touchend', function(event) {
  mouseButtonIsDown = false;
});

// Event listener for touch move
document.addEventListener('touchmove', function(event) {
  // Prevent default touch behavior (e.g., scrolling)
  event.preventDefault();
  handleInteraction(event.touches[0]);
}, { passive: false });

// Function to handle interaction (mouse or touch)
function handleInteraction(position) {
  if (eraseMode && mouseButtonIsDown) {
    var interactionPosition = { x: position.clientX, y: position.clientY };
    var bodiesUnderInteraction = Matter.Query.point(engine.world.bodies, interactionPosition);
    bodiesUnderInteraction.forEach(function(body) {
      if (body.label !== 'wall') {
        Matter.Composite.remove(engine.world, body);
      }
    });
  }
}

        // Run the engine
        Engine.run(engine);

        // Run the renderer
        Render.run(render);

// Function to change the background image of the canvas
function changeBackground(input) {
  if (input.files && input.files[0]) {
    var reader = new FileReader();
    reader.onload = function(e) {
      var canvas = document.getElementById('canvas');
      var ctx = canvas.getContext('2d');
      var img = new Image();
      img.onload = function() {
        // Clear the canvas before drawing the new background
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw the image onto the canvas, covering the entire area
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(input.files[0]);
  }
}

  </script>
</body>
</html>
